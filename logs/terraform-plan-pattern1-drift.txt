aws_vpc.conflict_test_vpc: Refreshing state... [id=vpc-0218366c7c30575ef]
aws_security_group.pattern2_sg: Refreshing state... [id=sg-09d3d503b238d6b14]
aws_security_group.pattern1_sg: Refreshing state... [id=sg-0b4eaa235eef61631]
aws_security_group_rule.pattern1_http: Refreshing state... [id=sgrule-1223500833]

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  ~ update in-place

Terraform will perform the following actions:

  # aws_security_group.pattern1_sg will be updated in-place
  ~ resource "aws_security_group" "pattern1_sg" {
        id                     = "sg-0b4eaa235eef61631"
      ~ ingress                = [
          - {
              - cidr_blocks      = [
                  - "0.0.0.0/0",
                ]
              - description      = "HTTP (using aws_security_group_rule)"
              - from_port        = 80
              - ipv6_cidr_blocks = []
              - prefix_list_ids  = []
              - protocol         = "tcp"
              - security_groups  = []
              - self             = false
              - to_port          = 80
            },
            # (1 unchanged element hidden)
        ]
        name                   = "pattern1-inline-and-sg-rule"
        tags                   = {
            "Name" = "pattern1-sg"
        }
        # (8 unchanged attributes hidden)
    }

Plan: 0 to add, 1 to change, 0 to destroy.

─────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
